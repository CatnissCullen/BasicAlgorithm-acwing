# 静态堆



#### 实现

完全二叉树（以小根堆为例），每个结点小于等于左右孩子，用一维数组heap存储，堆的结点个数用heapSize记录



##### 存储

下标**从1起**（方便求左右孩子下标），按层序存储，索引值为层序次序：

- **heap[i]**：在堆中索引为 i 的结点，第 i 个结点的<u>**左孩子**是第 2\*i 个结点</u>，<u>**右孩子**是第 2\*i+1 个结点</u>
- （据题目要求考虑是否需要）**nodeIndexs[j]**：存放**第 j 个插入的元素**在堆中的索引
- （据题目要求考虑是否需要）**nodeNums[i]**：存放**堆中层序为 i 的数**的插入次序



##### 操作

（带插入次序的堆操作见代码文件）

- **基本操作**（其他操作用这两个组合），时间复杂度都是$O(\log{n})$ 

  - down(int k) //<u>**调整以k位置为根结点的子堆**</u>：某结点的值变大后，将它往下沉（与三个结点中最小值交换）

    ```c++
    void down(int k){//调整以k为根结点的子堆
        int t=k;
        if(2*k<=size&&heap[2*k]<heap[t]) t=2*k;
        if(2*k+1<=size&&heap[2*k+1]<heap[t]) t=2*k+1;
        if(t!=k){
            Swap(heap[k],heap[t]);
            down(t);//t位置的元素被交换（有改动），则需重新调整以其为根的子堆
        }
    }
    ```

    **从下往上down用于建堆（无论大小顶）！**（或者从上往下up(int k)，一般用前者；**无论如何，调整方向应与遍历方向相反，调整过程才能覆盖到全部被改动过的点！**）

    ```c++
    //建堆（小顶堆）
    for(int i=n/2;i>0;--i) down(i); //调整为小顶堆：从倒数第二层最后一个结点往上down()，时间复杂度O(n)
    ```

    

  - up(int k) //将某结点的值变小后，将它往上浮（只用跟父结点比较，更小则交换）

    ```c++
    void up(int k){
        while(k/2>0&&heap[k/2]>heap[k]){
            Swap(heap[k/2],heap[k]); k/=2;
        }
    }
    ```

    

- 插入结点

  ```c++
  heap[++heapSize]=x;//先插在堆尾
  up(size);//再往上浮（底层的空结点可看作无穷大）
  ```

- 求最小值

  ```c++
  return heap[1];//返回堆顶
  ```

- 删除最小值（堆顶）

  ```c++
  heap[1]=heap[size];//先换到堆尾（其实是直接用堆尾覆盖堆顶，因为堆顶值已经不需要了）
  size--;//再删除堆尾（数组删除末位最方便）
  down(1);//然后重新将堆顶下沉（调整堆顶为当前最小值）
  ```

- 删除任意元素（STL 不可直接实现）

  ```c++
  heap[k]=heap[heapSize];//先换到堆尾（其实是直接用堆尾覆盖k位置，因为堆顶值已经不需要了）
  heapSize--;//再删除堆尾（数组删除末位最方便）
  down(k);up(k);//然后重新调整位置k（上浮或下沉，无需特判，都执行一次，实际只有其一有效）
  ```

- 修改任意元素（STL 不可直接实现）

  ```c++
  heap[k]=x;
  down(k);up(k);//重新调整位置k（上浮或下沉，无需特判，都执行一次，实际只有其一有效）
  ```

  



