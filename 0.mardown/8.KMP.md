# KMP（字符串模式匹配）

***(字符串下标从 1 起！)***

#### 目的

找到模板串 s{n} 在主串 a{m} 中所有出现的位置，且：

设前一趟匹配的第一个不同字符处，在模板串中为 i+1，则模板串**下次前进**的步数 i-j，是使得其在移动之后，**其前缀 s[1,j] 与部分模板串 s[i-j+1,i]** （即与主串对齐部分）**完全相同**的<u>最少步数</u>（即**相同部分长度最大**），以下称这样的前缀为**让步前缀**

![](D:\CAMPUS\编程相关专业课\算法\基础算法\0.mardown\images\Snipaste_2023-01-17_02-14-32.png)

*（绿圈和红圈是第一处不同的字符，下一位置模板串中的绿色部分与主串中对齐的部分相同，也与模板串的某前缀相同，即与主串无关）*

![](D:\CAMPUS\编程相关专业课\算法\基础算法\0.mardown\images\Snipaste_2023-01-17_02-06-03.png)



#### 实现

本质是对**模板串**的一种**预处理**：求**next_I数组**

![](D:\CAMPUS\编程相关专业课\算法\基础算法\0.mardown\images\Snipaste_2023-01-17_01-47-57.png)

**next_I[i]=j**：模板串中，与 **s[i-j+1,i]** 完全相同的**最长前缀为 s[1,j]**，**前缀长度为 j**，当模板串在第 i 处与主串不同时，前进步数即为 i-j

对于每个 a[k]，让步前缀 s[1,j] 从 s[1,0]（无让步前缀，**但其实相当于开始时的前缀为 s[1,i]，是最长的前缀**）开始，遇到不同字符则<u>先变为最长的 s[1,j]</u>，若 a[k] 与该让步前缀后的第一位仍不同，则继续更新 j，让步前缀开始缩短（**j ==开始回退，不断让步==**），直到遇到相同字符或 j 回退到 0；然后判断当前让步前缀的下一位是否是相同字符，是则**==让步有效==**， **j 前进一位**（这一步是对前面while循环的补充），否则**==让步无效==**， **j 在 0 处不动**（让步到退无可退）；每轮for循环最后，判断 j 是否已到达 n，是则已匹配成功一次

```c++
//求next_I
    for(int i=2,j=0;i<=n;++i){//与正式匹配的过程类似
        while(j>0&&s[i]!=s[j+1]) j=next_I[j];
        if(s[i]==s[j+1]) ++j;
        next_I[i]=j;//记录让步前缀尾下标（在j前进以后！）
    }
    //KMP匹配过程
    for(int k=1,j=0;k<=m;++k){//k是主串中的下标，j是模板串前缀的尾下标，初始时为0
        while(j>0&&a[k]!=s[j+1]) j=next_I[j];//当j没有退回模板串开头且根据next_I后移没遇到匹配字符
        if(a[k]==s[j+1]) ++j;//退出循环后，要么j=0，要么a[k]==s[j+1]，都需要更新j；若j=0，直接进入下一趟匹配利用next_I更新，若a[k]==s[j+1]则j前进一位
        if(j==n){
            printf("%d ",k-n); //一趟匹配结束，若匹配成功，输出位置，否则直接进入下一趟匹配
            j=next_I[j];//匹配成功也要回退！可能在回退过程中还有成功的匹配
        }
    }
```

