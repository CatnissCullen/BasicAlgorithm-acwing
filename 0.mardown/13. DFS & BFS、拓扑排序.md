[TOC]





# DFS & BFS



#### 共同目的

**对整个非线性空间进行遍历**



## 普通 DFS

（不只适用于图）



#### 目的

**不利用额外空间**进行遍历，在<u>**前面**的遍历会**影响后面**的遍历</u>的约束下（类似排列组合问题中带要求的全排列问题），**<u>求满足某要求的所有解</u>**（可能需要利用这些解求某最优解，但不是直接一边遍历一边找最优解）

![](D:\CAMPUS\编程相关专业课\算法\基础算法\0.mardown\images\Snipaste_2023-01-21_19-19-05.png)





#### 实现



##### 特点

-   <u>执着于往深/前搜（树：前序遍历），“兔子不吃窝边草”</u>

-   **普通DFS关键**：确定**搜索顺序**，与<u>前遍历对后遍历的约束</u>有关

    （没有树/图，需要自己确定“深度优先”**优先的指标**，**构造“深”的方向**，构造完要<u>能够画出**搜索树**或**搜索图**</u>；

    但**不用存储树/图**，<因为<u>可根据题目规律知道下一结点是什么</u><u>，而一般的树/图各结点间没有关联规律</u>>，**搜索过程即建树/图过程！**）





##### 存储

-   利用**栈**，空间 $O(d)$（**递归时系统调用的栈**）
-   可能需要自行**建立数组存储搜索路径**（<u>路径</u>指沿搜索树/图的<u>**深度方向**走到底</u>的一趟遍历，可能是二维的，如“八皇后问题”的一种布局），用于**记录和获取系统栈中完整路径上具体的结点内容**（若不需要获取完整路径则不需要该数组）
-   也有可能需要**额外空间**用于**确定搜索顺序**，即用于记录**前遍历对后遍历的约束** 





##### 算法

==**递归的深度即搜索深度，递归层内的循环即搜索宽度**==

**深度优先** =》【深搜=循环嵌套递归】每轮循环先递归（深度方向）后<u>撤销</u>再进入下一轮循环（宽度方向）

通用模板

```c++
void DFS(StatusType Status(i)){//i记录当前路径上的步数号，从0或1起（从main函数传入），一种路径共n步，第i步共mi种选择（mi叉路）
    if(i>n){                   //若步数已超过路径总步数，则已获得完整路径
        OperateRoute();        //对完整路径进行操作
        return;                //回溯：到第n步
    }
    for(int j=1;j<=mi;++j){    //每层递归的循环（宽度方向）遍历在i以前确定的步的约束下，路径第i步的所有选择
        if(Judge(i,j)){        //生枝：判断选择ij是否满足搜索顺序的要求（不满足的直接剪枝，遍历下一个j）
            SetStep(i,j);      //若满足，设置选择ij已在路径的第i步上
            DFS(Status(i+1));  //递归dfs，前进到第i+1步
            ClearStep(i,j);    //递归完返回第i步（即返回当前递归层），撤销递归前对第i步的操作
        }
    }
    return;                    //回溯：第i步所有选择遍历完毕，到第i-1步
}
```





## 普通 BFS

（不只适用于图）



#### 目的

一边遍历一边**找最优解**：当**各边等权**时，求解**从起点到某种满足某要求的点**的**最短路径**或**离起点最近的这种点**（遍历到某个点时走的是**从起点开始能到该点的最短路径**）

<img src="D:\CAMPUS\编程相关专业课\算法\基础算法\0.mardown\images\Snipaste_2023-01-21_19-20-59.png" style="zoom:80%;" />





#### 实现



##### 特点

<u>眼观六路耳听八方（树：层序遍历），“好马不吃回头草”</u>





##### 存储

-   利用**队列**，空间 $O(n)$（**自己实现的队列**）
-   再开一个数组steps[N]<u>记录从各点到起点的**最短路径长（步数）**</u>



##### 算法

1.  把初始状态（求解起点）入队
2.  队头出队，扩展队头，扩展所得从队尾入队，直至队空

通用模板

```c++
int BFS(){
    PushStartingPoint();                   //起点入队
	while(q.front<=q.rear){                //当队列不空
        f=Pop();                           //队头出队
        for(int i=0;i<k;++i){              //扩展队头：获取队头f的所有（k个）分支结点，并入队
            steps[Child(i,f)]=steps[f]+1;  //更新当前分支步数 
            if(Judge(i)) Push(Child(i,f)); //按要求获取队头的一个分支结点
        }
    }                                      //直至队空
    return steps[EndingPoint];             //返回终点步数（即最短路）
}

```





## 静态邻接表

（用一维数组模拟邻接表）

（直接考虑有向图，树是特殊的图，无向图是特殊的有向图；*⚠️无向图建图时根据输入的边在邻接表中对称地生成两条边* ：AddEdge(a,b); AddEdge(b,a); <若只是遍历也可以不用>）



**类似静态单链表：**

N为最多顶点数，M=2*N（有向图边数最多为顶点数的两倍）

输入：n（顶点数）-> 边集（“头顶点数据 尾顶点数据”）

⚠️ **存储内容**：*顶点**数据值**、尾顶点/边的**读入次序***（**<u>以读入次序模拟指针指向的内存地址</u>**）

【对比**邻接矩阵**行列坐标</u>存储内容：顶点**数据值映射到的索引**】

**⚠️ 结构体**：

```c++
typedef struct{
    ElemType dta;//结点数据值
//  WghType w;//出边权值
    int nxt;//下一尾顶点地址（用idx模拟）
}TlNode;//邻接链表结点（尾顶点）
```

**⚠️ 预处理：必须先初始化题目中所有顶点的fstEdge为-1、in为0，以防数据含孤立点，不会读入（若顶点数据不是有序值，题目必会先列出全部顶点数据，一 一读入初始化map即可）**

【对比 **邻接矩阵预处理**：若顶点数据值不是1-n的数值，**将数据值映射成1-n**】

-   **idx**：可变索引，值为当前未占用最小索引（是**边/尾顶点==读入的次序==**），从0起；<u>邻接链表中顶点（尾顶点）的索引是读入次序，模拟指针指向的内存地址</u>

-   ==**首出边集 fstTail**==：**数据值➡️地址**；**fstEdge[data]=i** —— 值为data的顶点的边表中，首出边为第 i 条边；用 <u>map\<ElemType, int\></u> 存储；在main函数一次性全部<u>初始化为-1</u>（用-1索引表示NULL）

-   ==**出边表集 tlLists[M]**==：**地址➡️结点结构体（含数据值和下一地址）**；**tlLists[i]=j** —— 在第 i 条边头顶点的出边表中，下一条边为第 j 条边；<u>一个tlLists数组**含有多个连通集**</u>（类似Kruskal算法中记录连通分量的数组），即多个<u>以 i=fstTail[data] 为首出边的**出边表**</u>（data为头顶点数据）

    

**头插法建图：**

```c++
void AddEdge(ElemType dt1,ElemType dt2){
    tlLists[idx].dta=dt2;//读入第idx条边的尾顶点数据（tlLists中的dt2可能出现多次，是多条边的尾顶点）
    tlLists[idx].nxt=fstTail[dt1]; fstTail[dt1]=idx;//边dt1->dt2以头插法入头顶点的出边表
    ++in[dt2];//尾顶点入度增一
    ++idx;
}
```





## 图的 DFS



##### 存储

在静态图邻接表存储的基础上外加：

-   **flag[N]**：flag[data]标记DFS中是否已遍历过data顶点，用 map\<ElemType, bool\> 存储





##### 算法

==**递归的深度即搜索深度，递归层内的循环即搜索宽度**==

**深度优先** =》【深搜=循环嵌套递归】每轮循环内递归（深度方向）后进入下一轮循环（宽度方向）

从起点开始**一直走到尽头**，**回溯到新起点**，以此类推：

```c++
//非连通图需要在main函数循环DFS，起点遍历所有顶点且先判断flag，flag不存在才进入DFS！
void DFS(ElemType hdDta){                                 //一层递归遍历一个头顶点的尾顶点集
    Operate(hdDta);                                       //操作头顶点
    flag[hdDta]=true;                                     //标记当前头顶点已被遍历到
    for(int j=fstEdge[hdDta];j!=-1;j=nxtEdge[j]){         //从首出边开始遍历头顶点的出边表（直到next为NULL）
        int tlDta=tlLists[j].dta;                         //获取某尾顶点的数值
        if(flag.find(tlDta)==flag.end()) DFS(tlDta);      //递归遍历该尾顶点的尾顶点集
        //（可能有撤销操作）                                 //回溯到头顶点的递归层，继续遍历其尾顶点集
    }
}
```





#### DFS 求遍历并回溯到起点的完整路径（即每条边走两遍）

我们在回顾前辈们艰苦卓绝的战争生活的同时，真心钦佩他们的聪明才智。在现在和平发展的年代，对多数人来说，探索地下通道或许只是一种娱乐或者益智的游戏。本实验案例以探索地下通道迷宫作为内容。

假设有一个地下通道迷宫，它的通道都是直的，而通道所有交叉点（包括通道的端点）上都有一盏灯和一个开关。请问你如何从某个起点开始在迷宫中点亮所有的灯并回到起点？

![img](https://images.ptausercontent.com/53)

输入格式:

输入第一行给出三个正整数，分别表示地下迷宫的节点数N（1<N≤1000，表示通道所有交叉点和端点）、边数M（≤3000，表示通道数）和探索起始节点编号S（节点从1到N编号）。随后的M行对应M条边（通道），每行给出一对正整数，分别是该条边直接连通的两个节点的编号。

输出格式:

若可以点亮所有节点的灯，则输出从S开始并以S结束的包含所有节点的序列，序列中相邻的节点一定有边（通道）；否则虽然不能点亮所有节点的灯，但还是输出点亮部分灯的节点序列，最后输出0，此时表示迷宫不是连通图。

由于深度优先遍历的节点序列是不唯一的，为了使得输出具有唯一的结果，我们约定以节点小编号优先的次序访问（点灯）。在点亮所有可以点亮的灯后，以原路返回的方式回到起点。

输入样例1:

```basic
6 8 1
1 2
2 3
3 4
4 5
5 6
6 4
3 6
1 5
```

输出样例1:

```basic
1 2 3 4 5 6 5 4 3 2 1
```

输入样例2:

```basic
6 6 6
1 2
1 3
2 3
5 4
6 5
6 4
```

输出样例2:` `

```basic
6 4 5 4 6 0
```



```c++
# include <iostream>
# include <cstring>
# include <vector>
using namespace std;
int n,m,s;
int g[1010][1010];
vector<int> r;
int cnt;
int flg[1010];
void dfs(int s){
    if(cnt!=1) cout<<" ";
    cout<<s;
    for(int i=1;i<=n;++i){
        if(g[s][i]&&!flg[i]){
            flg[i]=1; ++cnt;
            dfs(i);
            cout<<" "<<s;//回溯后输出当前的根结点（而不是i！！！）
        }
    }
}
int main(){
    cin>>n>>m>>s;
    while(m--){
        int a,b;
        cin>>a>>b; g[a][b]=g[b][a]=1;
    }
    flg[s]=1; ++cnt; 
    dfs(s);
    
    if(cnt!=n){
        cout<<" "<<0;
    }
}
```





#### 借助 DFS 求深度进而求遍历树上所有顶点的最短路长（图不行）

龙龙是“饱了呀”外卖软件的注册骑手，负责送帕特小区的外卖。帕特小区的构造非常特别，都是双向道路且没有构成环 —— 你可以简单地认为小区的路构成了一棵树，根结点是外卖站，树上的结点就是要送餐的地址。

每到中午 12 点，帕特小区就进入了点餐高峰。一开始，只有一两个地方点外卖，龙龙简单就送好了；但随着大数据的分析，龙龙被派了更多的单子，也就送得越来越累……

看着一大堆订单，龙龙想知道，从外卖站出发，访问所有点了外卖的地方至少一次（这样才能把外卖送到）所需的最短路程的距离到底是多少？每次新增一个点外卖的地址，他就想估算一遍整体工作量，这样他就可以搞明白新增一个地址给他带来了多少负担。

输入格式:
输入第一行是两个数 N 和 M  ( 2 ≤ N ≤ 1 0 5 , 1 ≤ M ≤ 1 0 5 ) (2≤N≤10^5 , 1≤M≤10^5 ) (2≤N≤105,1≤M≤105)，分别对应树上节点的个数（包括外卖站），以及新增的送餐地址的个数。
接下来首先是一行 N 个数，第 i 个数表示第 i i i 个点的双亲节点的编号。节点编号从 1 到 N ，外卖站的双亲编号定义为 − 1 。
接下来有 M 行，每行给出一个新增的送餐地点的编号 X i  。保证送餐地点中不会有外卖站，但地点有可能会重复。
为了方便计算，我们可以假设龙龙一开始一个地址的外卖都不用送，两个相邻的地点之间的路径长度统一设为 1，且从外卖站出发可以访问到所有地点。
注意：所有送餐地址可以按任意顺序访问，且完成送餐后无需返回外卖站。

输出格式:
对于每个新增的地点，在一行内输出题目需要求的最短路程的距离。

输入样例:

```
7 4
-1 1 1 1 2 2 3
5
6
2
4
```



    1
    2
    3
    4
    5
    6

输出样例:

```
2
4
4
6
```



```c++
#include<iostream>
#include<vector>
using namespace std;
const int N = 200010;
vector<int> g[N];
int d[N],f[N];//每个点的深度以及父结点
int maxn;//已有地址中的最远深度
int v;//每条边都走两次时的总路长，即上一题遍历完回溯到起点的路长（由于是树，最短总路长为 v-maxn，若是图则不符合！！）
bool st[N];//标记是否是已加入v的地址
void dfs(int u)//深搜并记录完整树每个点到起点的深度，用于以后求maxn
{
	for(auto &j:g[u]){
		d[j]=d[u]+1;
		dfs(j);
	}
}
int main()
{
	int n,m;cin>>n>>m;
	
	int root;
	for(int i=1;i<=n;i++) 
	{
		cin>>f[i];
		if(f[i]==-1) root=i;
		else g[f[i]].push_back(i);
	}
	
	dfs(root);
	
	v=0;
    int maxn=0;
	for(int i=1;i<=m;i++)
	{
		int x;cin>>x;
		maxn=max(maxn,d[x]);//更新maxn
		while(!st[x] && x!=root)//从当前新地址起回溯，直到遇到到已有地址或外卖站
		{
			st[x]=true;//回溯途径的未添加地址都先标记st，并加入v，以后添加时，由于比更深的点晚添加，遍历总路径按之前的v减当前maxn算，不会进入while循环
			v+=2;//加2表示正走和回溯每条边共走两次
			x=f[x]; //回溯
		}
		cout<<v-maxn<<endl;//计算当前总最短路长
	}
	return 0;
}

```





## 图的 BFS

（直接考虑有向图，树是特殊的图，无向图是特殊的有向图）

##### 存储

在静态图邻接表存储的基础上外加：

-   **qu[]**：BFS辅助队列
-   **d[N]**：起点到各点的距离（步数），用 map \<ElemType,int\> 存





##### 算法

1.  把初始状态（求解起点）入队
2.  队头出队，扩展队头，扩展所得从队尾入队，直至队空

依次遍历**到起点距离从小到大**的点

```c++
//非连通图需要在main函数循环BFS，起点遍历所有顶点且先判断d，d不存在才进入BFS！
void BFS(ElemType stDta){
    f=0,r=-1;
    qu[++r]=stData;                                        //起点入队
    d[stDta]=0;                                            //起点到本身的距离为0
    while(f<=r){                                           //当队不空
        ElemType hdDta=qB[f++];                            //取出队头
        Operate(hdData)                                    //操作队头
        for(int j=fstTail[hdDta]; j!=-1; j=tlLists[j].nxt){//遍历队头各尾顶点
            ElemType tlDta=tlLists[j].dta;                 //获取尾顶点数据值
            if(d.find(tlDta)==d.end()){                    //若当前尾顶点未被遍历过（可能也是别的队头的尾顶点，已经被遍历过）
                d[tlDta]=d[hdDta]+1;                       //更新队头尾顶点到队头的距离
                qB[++r]=tlDta;                             //尾顶点入队
            }
        }
    }
}
```







## 拓扑排序

（专用于有向图）



#### 目的

检查有向图**是否有环**；对<u>有向无环图**生成拓扑序列**</u>





#### 实现



##### 存储

在静态图邻接表存储的基础上外加：

-   **in[N]**：记录各顶点入度（AddEdge中加上in的处理），用 map\<ElemType,int\> 存储，在main函数全部一次性初始化为0





##### 算法

**类似BFS：**

1.  所有入度为0的点入队

2.  队头出队，枚举队头以及队头的所有尾顶点，

    并且<u>模拟删除队头到某尾顶点的边</u>：直接使尾顶点<u>入度减一</u>，

    若入度减为0，则该尾顶点入队

3.  循环 2 直到队空（若有环则队空时尾指针移不到n-1处），最终整个队列数组（从0到n-1）是无环图拓扑序列（即出队顺序）

```c++
bool TopologicalSort(){
    f=0,r=-1;
    for(pair<ElemType,int> it:in)                          //将所有入度为0的点入队
        if(!it.second) qT[++r]=it.first;
    while(f<=r){
        ElemType hdDta=qT[f++];                            //队头出队
        Operate(hdDta);                                    //操作队头（出队顺序是拓扑序列）
        for(int i=fstEdge[hdDta];i!=-1;i=tlLists[i].nxt){  //遍历队头各尾顶点
            ElemType tlDta=tlLists[i].dta;                 //获取一个队头尾顶点
            --in[tlDta];                                   //尾顶点入度减一（模拟删除队头到尾顶点的边）
            if(!in[tlDta]) qT[++r]=tlDta;                  //若尾顶点入度减至0则入队
        }                                        
    }                                                      //队空，入过队的顶点已进入序列
    return r==n-1;                                         //若队列尾指针最终能到达n-1处，说明无环，所有顶点已进入拓扑序列
}                                                          //若是无环图，则最终qT整个数组是拓扑序列
```

