# 双指针



### I. 两个指针指向不同序列



举例：归并排序





### II. 两个指针指向同一序列



举例：快速排序





### 写法



时间复杂度：$O(n)$

通用：（若 i、j 指向不同数组也可参考归并排序的循环形式）

```c++
//j=x（j的起点与i无关）
for(int i=0;i<n;i++){
    //j=x（j的起点与i有关）
    while(pos(i,j)&&check(i,j)) ++j;
    //每道题的具体逻辑
}//i每移一步j移动不超过n步，j总共移动也不超过n步
//pos为i与j间的大小关系（决定了j每轮for内移动的最大范围），check为题目中i与j所指元素的某种关系（决定了j在每轮可移动范围内何时提前停下）【有可能满足check时必满足pos，即pos可省略】
```

- 关于check函数：
  - 情况1：判断的是 **<u>i、j 各自所指元素</u>**的某种性质（这种情况下，**i、j是并列关系**，在同一数组中相向移动或两数组中同向移动）
  - 情况2：判断的是 <u>**[i,j] 区间内元素**</u>的某种性质（这种情况下，**i、j是追逐关系**，同向移动且 j 尾随 i，<u>*必须借助额外空间判断 j 何时前移*</u>）
- 一般**先从暴力算法出发再思考**如何改进成双指针算法
- 必须==**保证 i、j 都不走回头路**==，即<u>*每次循环都接着上次的位置继续沿各自的方向移动*</u>



### 作用



核心思想：利用题目中 <u>i 与 j 间**不变**的关系</u>，建立pos与check函数，以**限制 j** 在每轮for循环下的**移动范围**，使所有循环的过程中 ==**i、j 都不走回头路**==，从而将暴力的双层for循环（时间复杂度 $O(n^2)$ ）

```c++
for(int i=0;i<n;++i)
    for(int j=0;j<n;++j)
        //xxxxxxxxxxx
//i每移一步j都要移动n步        
```

**简化** 为 $O(n)$ 的时间复杂度。

