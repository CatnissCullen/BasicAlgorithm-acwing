（完整代码详见程序包）

# 一维前缀和



## 定义



$a_1,a_2,...,a_i,...a_n$ 的**前缀和**：

规定，

当 $i=0，S_i=0；\ $

当 $i!=0，S_i=a_1+a_2+...+a_i$ 。





## 求法（预处理）



已知原序列 a{n}

时间复杂度：$O(n)$



```c++
for(int i=1;i<=n;++i) S[i] = S[i-1] + a[i];
```





## 作用



可以借前缀和数组 $S$ **快速**求得原数组中任意一段元素的和：

$a_l+a_{l+1}+...+a_{r-1}+a_r=S_r-S_{l-1}$ （l、r为任意**正数**）

时间复杂度：$O(1)$ 



```c++
a[l] + a[l+1] + ... + a[r] = S[r] - S[l-1];
```

如果只处理一个区间的元素，则总时间复杂度没有改进。若要**处理大量区间**，则时间复杂度可明显缩短（因为大量区间总共的元素数可能是**好几倍的n**，而求前缀和数组的时间复杂度仅是1倍的n）。



# 二维前缀和



## 定义



$S_{ij}$：从 $a_{11}$ 到 $a_{ij}$ 的**矩阵上**所有元素的和





## 求法（预处理）



```c++
S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + a[i][j];
```





## 作用



可以借前缀和数组 $S$ **快速**求得原矩阵中任意一子矩阵（$<(x_1,y_1),\ (x_2,y_2)>$，前一坐标为左上角点的（行，列）下标，后一坐标为右下角点的（行，列）下标，为任意**正数**）的和：

$a_{x_1y_1}+...+a_{x_2y_2}=S_{x_2y_2}-S_{x_2(y_1-1)}-S_{(x_1-1)y_2}+S_{(x_1-1)(y_1-1)}$  



```c++
a[x1][y1] + ... + a[x2][y2] = S[x2][y2] - S[x2][y1-1] - S[x1-1][y2] + S[x1-1][y1-1]
```





# 一维差分

*（与前缀和互为逆运算，类似积分与微分的关系）*



## 定义



$a_1,a_2,...,a_i,...a_n$ 的**差分**：

规定，

当 $i=1，d_i=a_1；\ $

当 $i>1，d_i=a_i-a_{i-1}$ 。

$构造\ d_1,d_2,...,d_n，s.t. \ a_i=d_1+d_2+...+d_i，则称\ d\{n\}\ 为$$\ a\{n\}\ 的差分，a\{n\}\ (\ 加上\ a_0=0\ )\ 为\ b\{n\}\ 的前缀和数组。$





## 求法（预处理）

  

已知原序列 a{n}

具体解释见**作用**。

时间复杂度：$O(n)$



```c++
/*用Insert函数根据a预处理d*/
for(int i=1;i<=n;++i) Insert(i,i,a[i]);
```





## 作用



当要对区间 $[\ l,r\ ]$ 各元素前插入 $c$（ $即各元素加c，即前移c$），无需遍历 $a_l$ 至 $a_r$  （ $时间复杂度O(n)$ ），只要 $d_l+c$ 且 $d_{r+1}-c$ ，最后再求 $d\{n\}$ 的前缀和得到新的 $a\{n\}$ **（可原地转化）**即可。

$a\{n\}$ 本身的建立也可看成是全为0的数组经过**各 $[\ i,i\ ]$ 区间前插入 $a_i$** 后的结果，因此**可将 $d\{n\}$ 的构造看成这样的插入过程。**

单个区间插入 $c$ 过程的时间复杂度：$O(1)$ 

![WeChat Image_20230106061022](D:\CAMPUS\编程相关专业课\算法\基础算法\0.mardown\images\WeChat Image_20230106061022.jpg)



```c++
void Insert(int l,int r,int c){
    d[l]+=c; d[r+1]-=c; 
}
/*对[l,r]区间每个元素加上c*/
Insert(l,r,c);
/*将d原地求前缀和变为a*/
for(int i=1;i<=n;++i) d[i]+=d[i-1]; 
```

